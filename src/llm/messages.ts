/**
 * Message types for LLM communication
 * Based on OpenAI types, simplified for Browser Use
 */

import { z } from 'zod';

function truncate(text: string, maxLength: number = 50): string {
  if (text.length <= maxLength) {
    return text;
  }
  return text.slice(0, maxLength - 3) + '...';
}

function formatImageUrl(url: string, maxLength: number = 50): string {
  if (url.startsWith('data:')) {
    // Base64 image
    const mediaType = url.includes(';') ? url.split(';')[0].split(':')[1] : 'image';
    return `<base64 ${mediaType}>`;
  } else {
    // Regular URL
    return truncate(url, maxLength);
  }
}

// Content parts schemas
export const ContentPartTextParamSchema = z.object({
  text: z.string(),
  type: z.literal('text').default('text'),
});

export const ContentPartRefusalParamSchema = z.object({
  refusal: z.string(),
  type: z.literal('refusal').default('refusal'),
});

export const SupportedImageMediaTypeSchema = z.enum([
  'image/jpeg',
  'image/png', 
  'image/gif',
  'image/webp'
]);

export const ImageURLSchema = z.object({
  url: z.string().describe('Either a URL of the image or the base64 encoded image data'),
  detail: z.enum(['auto', 'low', 'high']).default('auto'),
  media_type: SupportedImageMediaTypeSchema.default('image/png'),
});

export const ContentPartImageParamSchema = z.object({
  image_url: ImageURLSchema,
  type: z.literal('image_url').default('image_url'),
});

export const FunctionSchema = z.object({
  arguments: z.string().describe('The arguments to call the function with, as generated by the model in JSON format'),
  name: z.string().describe('The name of the function to call'),
});

export const ToolCallSchema = z.object({
  id: z.string().describe('The ID of the tool call'),
  function: FunctionSchema.describe('The function that the model called'),
  type: z.literal('function').default('function'),
});

// Message schemas
const MessageBaseSchema = z.object({
  role: z.enum(['user', 'system', 'assistant']),
  cache: z.boolean().default(false).describe('Whether to cache this message (Anthropic only)'),
});

export const UserMessageSchema = MessageBaseSchema.extend({
  role: z.literal('user').default('user'),
  content: z.union([
    z.string(),
    z.array(z.union([ContentPartTextParamSchema, ContentPartImageParamSchema]))
  ]).describe('The contents of the user message'),
  name: z.string().optional().describe('An optional name for the participant'),
});

export const SystemMessageSchema = MessageBaseSchema.extend({
  role: z.literal('system').default('system'),
  content: z.union([
    z.string(),
    z.array(ContentPartTextParamSchema)
  ]).describe('The contents of the system message'),
  name: z.string().optional(),
});

export const AssistantMessageSchema = MessageBaseSchema.extend({
  role: z.literal('assistant').default('assistant'),
  content: z.union([
    z.string(),
    z.array(z.union([ContentPartTextParamSchema, ContentPartRefusalParamSchema])),
    z.null()
  ]).describe('The contents of the assistant message'),
  name: z.string().optional(),
  refusal: z.string().optional().describe('The refusal message by the assistant'),
  tool_calls: z.array(ToolCallSchema).default([]).describe('The tool calls generated by the model'),
});

export const BaseMessageSchema = z.union([
  UserMessageSchema,
  SystemMessageSchema,
  AssistantMessageSchema
]);

// Type definitions
export type ContentPartTextParam = z.infer<typeof ContentPartTextParamSchema>;
export type ContentPartRefusalParam = z.infer<typeof ContentPartRefusalParamSchema>;
export type SupportedImageMediaType = z.infer<typeof SupportedImageMediaTypeSchema>;
export type ImageURL = z.infer<typeof ImageURLSchema>;
export type ContentPartImageParam = z.infer<typeof ContentPartImageParamSchema>;
export type Function = z.infer<typeof FunctionSchema>;
export type ToolCall = z.infer<typeof ToolCallSchema>;
export type UserMessage = z.infer<typeof UserMessageSchema>;
export type SystemMessage = z.infer<typeof SystemMessageSchema>;
export type AssistantMessage = z.infer<typeof AssistantMessageSchema>;
export type BaseMessage = z.infer<typeof BaseMessageSchema>;

// Helper classes with methods
export class UserMessageHelper implements UserMessage {
  role: 'user' = 'user';
  content: string | (ContentPartTextParam | ContentPartImageParam)[];
  name?: string;
  cache: boolean = false;

  constructor(data: UserMessage) {
    this.content = data.content;
    this.name = data.name;
    this.cache = data.cache ?? false;
  }

  get text(): string {
    if (typeof this.content === 'string') {
      return this.content;
    } else if (Array.isArray(this.content)) {
      return this.content
        .filter(part => part.type === 'text')
        .map(part => (part as ContentPartTextParam).text)
        .join('\n');
    }
    return '';
  }

  toString(): string {
    return `UserMessage(content=${truncate(this.text)})`;
  }
}

export class SystemMessageHelper implements SystemMessage {
  role: 'system' = 'system';
  content: string | ContentPartTextParam[];
  name?: string;
  cache: boolean = false;

  constructor(data: SystemMessage) {
    this.content = data.content;
    this.name = data.name;
    this.cache = data.cache ?? false;
  }

  get text(): string {
    if (typeof this.content === 'string') {
      return this.content;
    } else if (Array.isArray(this.content)) {
      return this.content
        .filter(part => part.type === 'text')
        .map(part => part.text)
        .join('\n');
    }
    return '';
  }

  toString(): string {
    return `SystemMessage(content=${truncate(this.text)})`;
  }
}

export class AssistantMessageHelper implements AssistantMessage {
  role: 'assistant' = 'assistant';
  content: string | (ContentPartTextParam | ContentPartRefusalParam)[] | null;
  name?: string;
  refusal?: string;
  tool_calls: ToolCall[] = [];
  cache: boolean = false;

  constructor(data: AssistantMessage) {
    this.content = data.content;
    this.name = data.name;
    this.refusal = data.refusal;
    this.tool_calls = data.tool_calls ?? [];
    this.cache = data.cache ?? false;
  }

  get text(): string {
    if (typeof this.content === 'string') {
      return this.content;
    } else if (Array.isArray(this.content)) {
      let text = '';
      for (const part of this.content) {
        if (part.type === 'text') {
          text += (part as ContentPartTextParam).text;
        } else if (part.type === 'refusal') {
          text += `[Refusal] ${(part as ContentPartRefusalParam).refusal}`;
        }
      }
      return text;
    }
    return '';
  }

  toString(): string {
    return `AssistantMessage(content=${truncate(this.text)})`;
  }
}

// Factory functions for content parts
export function createContentPartText(text: string): ContentPartTextParam {
  return ContentPartTextParamSchema.parse({ text });
}

export function createContentPartImage(url: string, detail: 'auto' | 'low' | 'high' = 'auto', media_type: SupportedImageMediaType = 'image/png'): ContentPartImageParam {
  return ContentPartImageParamSchema.parse({
    image_url: {
      url,
      detail,
      media_type
    }
  });
}

export function createContentPartRefusal(refusal: string): ContentPartRefusalParam {
  return ContentPartRefusalParamSchema.parse({ refusal });
}

export function createImageURL(url: string, detail: 'auto' | 'low' | 'high' = 'auto', media_type: SupportedImageMediaType = 'image/png'): ImageURL {
  return ImageURLSchema.parse({
    url,
    detail,
    media_type
  });
}

// Factory functions for messages
export function createUserMessage(content: string | (ContentPartTextParam | ContentPartImageParam)[], options?: Partial<UserMessage>): UserMessage {
  return UserMessageSchema.parse({
    content,
    ...options,
  });
}

export function createSystemMessage(content: string | ContentPartTextParam[], options?: Partial<SystemMessage>): SystemMessage {
  return SystemMessageSchema.parse({
    content,
    ...options,
  });
}

export function createAssistantMessage(content: string | (ContentPartTextParam | ContentPartRefusalParam)[] | null, options?: Partial<AssistantMessage>): AssistantMessage {
  return AssistantMessageSchema.parse({
    content,
    ...options,
  });
}